# Web 服务器项目

## 概述

本项目是一个高性能的 Web 服务器，旨在高效地处理大量并发连接。它采用 Reactor 模式，并使用事件驱动的编程模型来管理 I/O 操作。

## Web 服务器的工作过程

Web 服务器的主要任务是接收来自客户端（通常是 Web 浏览器或 Web 爬虫）的 HTTP 请求，处理这些请求，并将 HTTP 响应发送回客户端。以下是详细的工作过程：

### 1. 监听网络端口
服务器在指定的网络端口（通常是 80 端口用于 HTTP，443 端口用于 HTTPS）上监听传入的连接请求。

### 2. 接收 HTTP 请求
客户端向服务器的监听端口发送 HTTP 请求。请求包括请求行（例如 GET /index.html HTTP/1.1）、请求头（包含用户代理、接受的内容类型等信息）以及可能的请求体（主要用于 POST 请求）。

### 3. 解析请求
服务器接收到请求后，解析请求行和请求头，确定客户端想要执行的操作（如获取、提交或删除数据）和请求的资源（如 HTML 页面、图片或 API）。

### 4. 处理请求
解析请求后，服务器根据请求的类型和资源路径处理请求。这可能涉及从文件系统中检索静态资源（如 HTML 文件、图片等）或执行后端代码生成动态内容（如用户查询结果、表单处理结果等）。

### 5. 生成 HTTP 响应
处理完请求后，服务器生成一个 HTTP 响应发送回客户端。响应包括状态码（如 200 OK 表示成功，404 Not Found 表示资源未找到）、响应头（如内容类型、缓存控制信息等）以及响应体（请求的资源或错误信息）。

### 6. 发送响应到客户端
服务器将生成的 HTTP 响应通过网络发送回发起请求的客户端。客户端接收到响应后，根据响应的内容类型决定如何处理和显示响应体中的内容。

### 7. 记录日志
Web 服务器通常会记录每个请求和相应的响应的详细信息，包括请求的时间、IP 地址、请求的资源、响应状态码等。这些日志对于监控服务器的健康状况、用户行为分析以及调试问题都是非常有用的。

### 8. 等待下一个请求
完成上述所有步骤后，Web 服务器将继续监听端口，等待处理下一个请求。

## I/O 设计

网络 I/O 是 Web 服务器的核心组成部分，因为服务器需要不断地在网络上监听、接收、处理客户端的请求，并向客户端发送响应。这些操作涉及数据在网络套接字之间的传输，是典型的 I/O 操作。有效地管理网络 I/O 是提高 Web 服务器性能的关键，特别是在处理大量并发连接时。常见的网络 I/O 模型包括阻塞 I/O、非阻塞 I/O、I/O 多路复用（如 select、poll、epoll）、信号驱动 I/O 和异步 I/O，不同的模型对服务器的性能和资源利用率有着不同的影响。

## 主从 Reactor 模式

### Reactor 模式
Reactor 模式是一种用于并发处理服务请求的事件驱动编程模型。事件循环是 Reactor 模式运作的核心。

### 主从 Reactor 模式
在主从 Reactor 模式中，有两类 Reactor：
- **主 Reactor**：负责监听和接收客户端连接。当新的连接到达时，它将这个连接分配给一个从 Reactor。
- **从 Reactor**：负责处理已经建立的连接的 I/O 事件，例如读取数据、数据解码、业务逻辑处理和发送响应等。

### 事件循环的角色
事件循环在主从 Reactor 模式中扮演着至关重要的角色：
- **事件监听和分发**：事件循环不断地监听 I/O 事件（如新的连接请求、数据到达等）。一旦这些事件发生，事件循环将负责将它们分发给相应的处理器。
- **非阻塞操作**：通过事件循环，Reactor 可以以非阻塞的方式执行操作。这意味着主 Reactor 可以在不被单个连接或操作阻塞的情况下，继续接收新的连接，而从 Reactor 可以同时处理多个并发的 I/O 事件。
- **高效的并发处理**：事件循环使得从 Reactor 能够以高效的方式处理大量并发的 I/O 操作，因为它们可以在单个或少数几个线程上处理多个连接的事件，减少了线程上下文切换的开销。

## 主事件循环和工作线程

### 主事件循环
主事件循环主要负责两件事情：
1. **监听网络端口**：等待并接收新的连接请求。
2. **分配任务**：将接收到的连接请求分配给线程池中的一个线程进行进一步处理。

主事件循环确保服务器能够不断接收新的连接，同时将请求的实际处理委托给线程池中的线程，这样就可以并行处理多个请求。

### 线程池（EventLoopThreadPool）
线程池中的每个线程运行自己的事件循环，处理从主事件循环分配给它的连接。任务包括：
- **解析 HTTP 请求**：解析请求行、请求头和请求体。
- **处理请求**：根据请求类型和资源路径处理请求，包括访问文件系统获取静态资源或执行后端逻辑生成动态内容。
- **生成 HTTP 响应**：创建包含状态码、响应头和响应体的 HTTP 响应。
- **发送响应**：将生成的响应发送回客户端。
- **记录日志**：记录请求和响应的详细信息。
- **维护连接状态**：根据 HTTP 协议的要求管理 TCP 连接的状态。

## `Channel` 类

`Channel` 类封装了一个 I/O 源（如套接字）及其相关的事件处理。它提供了一个统一的接口来处理不同类型的网络事件，包括连接、读取和写入事件。

### 事件处理函数
- **读取（Read）**：当套接字上有数据可读时，`Channel` 会调用相应的读取处理函数来处理这个事件。
- **写入（Write）**：当套接字可写时，`Channel` 会调用写入处理函数。
- **连接（Connect）**：对于客户端套接字，在成功建立连接后，`Channel` 会调用连接处理函数。

### 事件循环的协作
- **注册与监听**：`Channel` 注册到一个事件循环中，事件循环负责监听和分发事件。当指定的事件发生时，事件循环会通知 `Channel`。
- **事件分发**：`Channel` 根据事件循环传来的事件类型，决定调用其内部的哪个事件处理函数。

## `HttpData` 类

`HttpData` 类负责读取、写入和连接操作的具体实现。它管理 HTTP 相关的逻辑，包括请求解析、响应生成和连接状态管理。

## 结论

本项目展示了如何使用事件驱动编程和 Reactor 模式实现一个高性能的 Web 服务器。通过高效管理网络 I/O 并利用多线程架构，服务器能够处理大量并发连接，并为现代 Web 应用提供响应迅速的性能。


